#include "server/socket_server.h"


Server::Server(int port) : clientSocket1(-1), clientSocket2(-1), isRunning(false) {
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serverSocket == -1) {
        std::cerr << "Failed to create socket." << std::endl;
        exit(EXIT_FAILURE);
    }

    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(port);

    if (bind(serverSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {
        std::cerr << "Binding failed." << std::endl;
        close(serverSocket);
        exit(EXIT_FAILURE);
    }

    if (listen(serverSocket, 2) < 0) {  // Only listen for 2 connections
        std::cerr << "Listening failed." << std::endl;
        close(serverSocket);
        exit(EXIT_FAILURE);
    }
    isRunning = true;
}

Server::~Server() {
    isRunning = false;
    close(clientSocket1);
    close(clientSocket2);
    close(serverSocket);
}

void Server::run() {
    while (isRunning) {
        if (clientSocket1 == -1) {
            acceptClient(clientSocket1);
            notifyClient(clientSocket1, "Connected. Waiting for another user...\n");
        }
        if (clientSocket2 == -1) {
            acceptClient(clientSocket2);
        }
        if (clientSocket1 != -1 && clientSocket2 != -1) {
            // Both clients are connected, now handle client interaction
            handleClient(clientSocket1, clientSocket2);
            // Reset client sockets after handling to accept new connections
            clientSocket1 = -1;
            clientSocket2 = -1;
        }
    }
}

void Server::acceptClient(int &clientSocket) {
    sockaddr_in clientAddr;
    socklen_t clientAddrLen = sizeof(clientAddr);

    // Attempt to accept a client connection
    clientSocket = accept(serverSocket, (struct sockaddr*)&clientAddr, &clientAddrLen);
    if (clientSocket < 0) {
        std::cerr << "Error accepting client: " << strerror(errno) << std::endl;
        clientSocket = -1;  // Reset the client socket to -1 to indicate failure
        return;  // Return and allow the server to attempt to accept another client
    }

    // Successfully accepted a client
    std::cout << "Client connected from " << inet_ntoa(clientAddr.sin_addr) << ":" << ntohs(clientAddr.sin_port) << std::endl;

    // Send a welcome message to the client
    notifyClient(clientSocket, "Welcome! You are now connected to the server.\n\n");
}

void Server::handleClient(int clientSocket1, int clientSocket2) {
    notifyClient(clientSocket1, "You are now chatting with User 2\n");
    notifyClient(clientSocket2, "You are now chatting with User 1\n");
    fd_set readfds;
    int max_sd;

    while (isRunning) {
        FD_ZERO(&readfds);

        // Add both sockets to the set
        FD_SET(clientSocket1, &readfds);
        FD_SET(clientSocket2, &readfds);
        max_sd = (clientSocket1 > clientSocket2) ? clientSocket1 : clientSocket2;

        // Wait for an activity on one of the sockets, timeout is NULL
        int activity = select(max_sd + 1, &readfds, NULL, NULL, NULL);

        if ((activity < 0) && (errno != EINTR)) {
            std::cerr << "select error" << std::endl;
        }

        // If something happened on the first socket, handle it
        if (FD_ISSET(clientSocket1, &readfds)) {
            char buffer[1024] = {0};
            ssize_t bytesRead = read(clientSocket1, buffer, sizeof(buffer) - 1);
            if (bytesRead == 0) {
                // Client disconnected, close the socket and break from loop
                close(clientSocket1);
                // Notify other user
                notifyClient(clientSocket2, "The other user disconnected.\n");
                close(clientSocket2);
                return;
            } else if (bytesRead > 0) {
                // Forward the message to the second client
                send(clientSocket2, buffer, bytesRead, 0);
            }
        }

        // If something happened on the second socket, handle it
        if (FD_ISSET(clientSocket2, &readfds)) {
            char buffer[1024] = {0};
            ssize_t bytesRead = read(clientSocket2, buffer, sizeof(buffer) - 1);
            if (bytesRead == 0) {
                // Client disconnected, close the socket and break from loop
                close(clientSocket2);
                clientSocket2 = -1;
                // Notify other user
                notifyClient(clientSocket1, "The other user disconnected.\n");
                close(clientSocket1);
                return;
            } else if (bytesRead > 0) {
                // Forward the message to the first client
                send(clientSocket1, buffer, bytesRead, 0);
            }
        }
    }
}

void Server::notifyClient(int clientSocket, const std::string &message) {
    send(clientSocket, message.c_str(), message.length(), 0);
}


void Server::handlePair(int clientSocket1, int clientSocket2) {
    notifyClient(clientSocket1, "You are now chatting with User 2\n");
    notifyClient(clientSocket2, "You are now chatting with User 1\n");
    fd_set readfds;
    int max_sd;

    while (isRunning) {
        FD_ZERO(&readfds);

        // Add both sockets to the set
        FD_SET(clientSocket1, &readfds);
        FD_SET(clientSocket2, &readfds);
        max_sd = (clientSocket1 > clientSocket2) ? clientSocket1 : clientSocket2;

        // Wait for an activity on one of the sockets, timeout is NULL
        int activity = select(max_sd + 1, &readfds, NULL, NULL, NULL);

        if ((activity < 0) && (errno != EINTR)) {
            std::cerr << "select error" << std::endl;
        }

        // If something happened on the first socket, handle it
        if (FD_ISSET(clientSocket1, &readfds)) {
            char buffer[1024] = {0};
            ssize_t bytesRead = read(clientSocket1, buffer, sizeof(buffer) - 1);
            if (bytesRead == 0) {
                // Client disconnected, close the socket and break from loop
                close(clientSocket1);
                // Notify other user
                notifyClient(clientSocket2, "The other user disconnected.\n");
                close(clientSocket2);
                return;
            } else if (bytesRead > 0) {
                // Forward the message to the second client
                send(clientSocket2, buffer, bytesRead, 0);
            }
        }

        // If something happened on the second socket, handle it
        if (FD_ISSET(clientSocket2, &readfds)) {
            char buffer[1024] = {0};
            ssize_t bytesRead = read(clientSocket2, buffer, sizeof(buffer) - 1);
            if (bytesRead == 0) {
                // Client disconnected, close the socket and break from loop
                close(clientSocket2);
                clientSocket2 = -1;
                // Notify other user
                notifyClient(clientSocket1, "The other user disconnected.\n");
                close(clientSocket1);
                return;
            } else if (bytesRead > 0) {
                // Forward the message to the first client
                send(clientSocket1, buffer, bytesRead, 0);
            }
        }
    }
}
